<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geometryc Runner</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: #0a0a0a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #gameArea {
            width: 100vw;
            height: 100vh;
            position: relative;
            background: linear-gradient(45deg, #0a0a0a, #1a1a1a);
            overflow: hidden;
            box-shadow: inset 0 0 100px rgba(128, 0, 255, 0.3);
        }
        
        #player {
            width: 30px;
            height: 30px;
            background: radial-gradient(circle at 30% 30%, #c17aff, #8a2be2);
            position: absolute;
            border-radius: 50%;
            box-shadow: 0 0 15px rgba(138, 43, 226, 0.8);
            transition: all 0.1s linear;
        }

        .enemy {
            width: 30px;
            height: 30px;
            position: absolute;
            border-radius: 50%;
            box-shadow: 0 0 15px rgba(153, 50, 204, 0.7);
            transition: all 0.1s linear;
        }

        .enemy-purple {
            background: radial-gradient(circle at 30% 30%, #ff79c6, #bd93f9);
        }

        .enemy-green {
            background: radial-gradient(circle at 30% 30%, #50fa7b, #00b894);
        }
        
        .enemy-yellow {
            width: 30px;
            height: 30px;
            background: radial-gradient(circle at 30% 30%, #f1fa8c, #ffb86c);
            border-radius: 50%;
            box-shadow: 0 0 15px rgba(241, 250, 140, 0.7);
        }
        
        .enemy-blue {
            width: 30px;
            height: 30px;
            background: radial-gradient(circle at 30% 30%, #8be9fd, #0077b6);
            clip-path: polygon(50% 0%, 100% 38%, 82% 100%, 18% 100%, 0% 38%);
            box-shadow: 0 0 15px rgba(139, 233, 253, 0.7);
        }

        .enemy-orange {
            width: 30px;
            height: 30px;
            background: radial-gradient(circle at 30% 30%, #ffb86c, #ff4500);
            border-radius: 50%;
            box-shadow: 0 0 15px rgba(255, 69, 0, 0.7);
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .slow-area {
            position: absolute;
            width: 120px;
            height: 120px;
            background: radial-gradient(circle, rgba(139, 233, 253, 0.3), rgba(0, 119, 182, 0.1));
            border-radius: 50%;
            border: 2px solid rgba(139, 233, 253, 0.5);
            pointer-events: none;
            z-index: -1;
            animation: pulse 2s infinite alternate;
        }
        
        @keyframes pulse {
            0% { opacity: 0.5; transform: scale(1); }
            100% { opacity: 0.8; transform: scale(1.05); }
        }
        
        .player-slowed {
            filter: drop-shadow(0 0 8px rgba(139, 233, 253, 0.8));
            animation: slow-pulse 1s infinite alternate;
        }
        
        @keyframes slow-pulse {
            0% { opacity: 0.8; }
            100% { opacity: 1; }
        }
        
        .enemy-blue::before {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            top: 5px;
            left: 5px;
            background: rgba(255, 255, 255, 0.7);
            clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);
            animation: rotate 3s linear infinite;
        }
        
        @keyframes rotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .enemy-yellow.piscando {
            animation: piscar 0.5s infinite alternate;
        }
        
        @keyframes piscar {
            0% { opacity: 1; }
            100% { opacity: 0.3; }
        }
        
        .explosion {
            position: absolute;
            width: 50px;
            height: 50px;
            background: radial-gradient(circle, #ff79c6, #bd93f9, transparent);
            border-radius: 50%;
            animation: explode 0.5s forwards;
            z-index: 100;
        }
        
        @keyframes explode {
            0% { transform: scale(0.5); opacity: 1; }
            100% { transform: scale(2); opacity: 0; }
        }
        
        .obstacle {
            width: 50px;
            height: 50px;
            background-color: #2d2d2d;
            position: absolute;
            border-radius: 5px;
            animation: pulsar 2s infinite alternate;
            transition: all 0.3s ease;
            border: 1px solid #8a2be2;
            box-shadow: 0 0 10px rgba(138, 43, 226, 0.5);
        }

        @keyframes pulsar {
            from { transform: scale(1); box-shadow: 0 0 10px rgba(138, 43, 226, 0.5); }
            to { transform: scale(1.05); box-shadow: 0 0 20px rgba(138, 43, 226, 0.8); }
        }

        #gameOver {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 10, 10, 0.9);
            color: #bd93f9;
            padding: 40px;
            text-align: center;
            border-radius: 15px;
            box-shadow: 0 0 30px rgba(138, 43, 226, 0.5);
            border: 1px solid #8a2be2;
        }

        #gameOver button {
            padding: 12px 25px;
            font-size: 18px;
            background: transparent;
            border: 2px solid #8a2be2;
            color: #bd93f9;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #gameOver button:hover {
            background: #8a2be2;
            color: white;
            box-shadow: 0 0 15px rgba(138, 43, 226, 0.8);
            transform: scale(1.05);
        }

        #timer {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #bd93f9;
            font-size: 28px;
            font-weight: bold;
            background: rgba(10, 10, 10, 0.7);
            padding: 10px 25px;
            border-radius: 50px;
            z-index: 100;
            box-shadow: 0 0 15px rgba(138, 43, 226, 0.5);
            border: 1px solid #8a2be2;
            letter-spacing: 2px;
        }

        #extraLifeIcon, #explosionIcon {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 30px;
            height: 30px;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 50%;
            display: none;
            z-index: 100;
            box-shadow: 0 0 15px rgba(138, 43, 226, 0.5);
            border: 1px solid #8a2be2;
        }

        #extraLifeIcon {
            background: url('shield-icon.png') no-repeat center center;
            background-size: cover;
        }

        #explosionIcon {
            background: url('explosion-icon.png') no-repeat center center;
            background-size: cover;
            top: 60px;
        }

        /* Estilos para a tela inicial */
        #telaInicial {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a0a, #1a1a1a);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            box-shadow: inset 0 0 150px rgba(138, 43, 226, 0.3);
            animation: backgroundAnimation 10s infinite alternate;
        }

        @keyframes backgroundAnimation {
            0% { background: linear-gradient(135deg, #0a0a0a, #1a1a1a); }
            100% { background: linear-gradient(135deg, #1a1a1a, #0a0a0a); }
        }

        #telaInicial h1 {
            color: #bd93f9;
            font-size: 60px;
            margin-bottom: 40px;
            text-shadow: 0 0 20px rgba(138, 43, 226, 0.8);
            font-weight: 800;
            letter-spacing: 3px;
            text-transform: uppercase;
        }

        .menu-button {
            padding: 15px 30px;
            font-size: 18px;
            background: transparent;
            color: #bd93f9;
            border: 2px solid #8a2be2;
            border-radius: 50px;
            margin: 12px;
            cursor: pointer;
            transition: all 0.3s;
            width: 220px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }

        .menu-button:hover {
            background: #8a2be2;
            color: white;
            box-shadow: 0 0 20px rgba(138, 43, 226, 0.8);
            transform: scale(1.05);
        }

        .menu-button::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            border-radius: 50px;
            background: linear-gradient(45deg, #8a2be2, #bd93f9, #8a2be2);
            z-index: -1;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .menu-button:hover::before {
            opacity: 1;
            animation: rotate 2s linear infinite;
        }

        #ultimaPontuacao, #melhorPontuacao {
            color: #bd93f9;
            font-size: 18px;
            margin: 8px 0;
            letter-spacing: 1px;
        }

        #pontuacoes {
            margin-top: 40px;
            padding: 20px;
            background: rgba(10, 10, 10, 0.7);
            border-radius: 15px;
            text-align: center;
            border: 1px solid #8a2be2;
            box-shadow: 0 0 15px rgba(138, 43, 226, 0.5);
        }
        
        /* Estilos para o ranking */
        #telaRanking {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a0a, #1a1a1a);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            box-shadow: inset 0 0 150px rgba(138, 43, 226, 0.3);
        }
        
        #telaRanking h2 {
            color: #bd93f9;
            font-size: 42px;
            margin-bottom: 30px;
            text-shadow: 0 0 15px rgba(138, 43, 226, 0.8);
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        #rankingList {
            width: 80%;
            max-width: 550px;
            background: rgba(10, 10, 10, 0.8);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            border: 1px solid #8a2be2;
            box-shadow: 0 0 20px rgba(138, 43, 226, 0.5);
        }
        
        .ranking-item {
            display: flex;
            justify-content: space-between;
            padding: 12px 15px;
            border-bottom: 1px solid #8a2be2;
            color: #f8f8f2;
            margin-bottom: 5px;
        }
        
        .ranking-item:last-child {
            border-bottom: none;
        }
        
        .ranking-position {
            font-weight: bold;
            color: #bd93f9;
            width: 30px;
        }
        
        .ranking-nick {
            flex-grow: 1;
            text-align: left;
            padding-left: 15px;
            color: #f8f8f2;
        }
        
        .ranking-tempo {
            font-weight: bold;
            color: #bd93f9;
        }
        
        /* Estilos para o formulário de nick */
        #nickForm {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 10, 10, 0.9);
            color: #bd93f9;
            padding: 40px;
            text-align: center;
            border-radius: 15px;
            box-shadow: 0 0 30px rgba(138, 43, 226, 0.5);
            z-index: 300;
            border: 1px solid #8a2be2;
        }
        
        #nickForm h3 {
            font-size: 28px;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #bd93f9;
        }
        
        #nickForm input {
            padding: 12px 15px;
            font-size: 16px;
            width: 220px;
            margin: 15px 0;
            border-radius: 8px;
            border: 2px solid #8a2be2;
            background: rgba(30, 30, 30, 0.8);
            color: #f8f8f2;
            outline: none;
        }
        
        #nickForm input:focus {
            box-shadow: 0 0 10px rgba(138, 43, 226, 0.8);
        }
        
        #nickForm button {
            padding: 12px 25px;
            font-size: 18px;
            background: transparent;
            border: 2px solid #8a2be2;
            color: #bd93f9;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        #nickForm button:hover {
            background: #8a2be2;
            color: white;
            box-shadow: 0 0 15px rgba(138, 43, 226, 0.8);
            transform: scale(1.05);
        }
        
        /* Estilos para a tela de configuração */
        #telaConfiguracao {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a0a, #1a1a1a);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            box-shadow: inset 0 0 150px rgba(138, 43, 226, 0.3);
        }
        
        #telaConfiguracao h2 {
            color: #bd93f9;
            font-size: 42px;
            margin-bottom: 30px;
            text-shadow: 0 0 15px rgba(138, 43, 226, 0.8);
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        #configForm {
            width: 80%;
            max-width: 550px;
            background: rgba(10, 10, 10, 0.8);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            border: 1px solid #8a2be2;
            box-shadow: 0 0 20px rgba(138, 43, 226, 0.5);
            text-align: center;
        }
        
        #configForm label {
            display: block;
            color: #f8f8f2;
            font-size: 18px;
            margin-bottom: 10px;
        }
        
        #configForm input {
            padding: 12px 15px;
            font-size: 16px;
            width: 80%;
            margin: 15px 0;
            border-radius: 8px;
            border: 2px solid #8a2be2;
            background: rgba(30, 30, 30, 0.8);
            color: #f8f8f2;
            outline: none;
        }
        
        #configForm input:focus {
            box-shadow: 0 0 10px rgba(138, 43, 226, 0.8);
        }
        
        #configForm button {
            padding: 12px 25px;
            font-size: 18px;
            background: transparent;
            border: 2px solid #8a2be2;
            color: #bd93f9;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        #configForm button:hover {
            background: #8a2be2;
            color: white;
            box-shadow: 0 0 15px rgba(138, 43, 226, 0.8);
            transform: scale(1.05);
        }

        /* Estilos para a tela de perks */
        #telaPerks {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 10, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 300;
            box-shadow: inset 0 0 150px rgba(138, 43, 226, 0.3);
        }

        #telaPerks h2 {
            color: #bd93f9;
            font-size: 42px;
            margin-bottom: 30px;
            text-shadow: 0 0 15px rgba(138, 43, 226, 0.8);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .perk-button {
            padding: 15px 30px;
            font-size: 18px;
            background: transparent;
            color: #bd93f9;
            border: 2px solid #8a2be2;
            border-radius: 50px;
            margin: 12px;
            cursor: pointer;
            transition: all 0.3s;
            width: 220px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }

        .perk-button:hover {
            background: #8a2be2;
            color: white;
            box-shadow: 0 0 20px rgba(138, 43, 226, 0.8);
            transform: scale(1.05);
        }

        .perk-button::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            border-radius: 50px;
            background: linear-gradient(45deg, #8a2be2, #bd93f9, #8a2be2);
            z-index: -1;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .perk-button:hover::before {
            opacity: 1;
            animation: rotate 2s linear infinite;
        }

        /* Estilos para a loja */
        #telaLoja {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 10, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 300;
            box-shadow: inset 0 0 150px rgba(138, 43, 226, 0.3);
        }

        #telaLoja h2 {
            color: #bd93f9;
            font-size: 42px;
            margin-bottom: 30px;
            text-shadow: 0 0 15px rgba(138, 43, 226, 0.8);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .color-picker, .background-picker {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 10px 0;
        }

        .color-option, .background-option {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            margin: 0 10px;
            cursor: pointer;
            transition: transform 0.3s;
        }

        .color-option:hover, .background-option:hover {
            transform: scale(1.1);
        }

        .color-option {
            background: radial-gradient(circle at 30% 30%, #c17aff, #8a2be2);
        }

        .background-option {
            background: linear-gradient(45deg, #0a0a0a, #1a1a1a);
        }

        .menu-button {
            padding: 15px 30px;
            font-size: 18px;
            background: transparent;
            color: #bd93f9;
            border: 2px solid #8a2be2;
            border-radius: 50px;
            margin: 12px;
            cursor: pointer;
            transition: all 0.3s;
            width: 220px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }

        .menu-button:hover {
            background: #8a2be2;
            color: white;
            box-shadow: 0 0 20px rgba(138, 43, 226, 0.8);
            transform: scale(1.05);
        }

        .menu-button::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            border-radius: 50px;
            background: linear-gradient(45deg, #8a2be2, #bd93f9, #8a2be2);
            z-index: -1;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .menu-button:hover::before {
            opacity: 1;
            animation: rotate 2s linear infinite;
        }

        .label {
            color: #bd93f9;
            font-size: 18px;
            margin: 8px 0;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        /* Estilos para o cursor no mobile */
        #mobileCursor {
            width: 30px;
            height: 30px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            position: absolute;
            display: none;
            z-index: 200;
        }

        /* Estilos para o botão de explosão no mobile */
        #explosionButton {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 60px;
            height: 60px;
            background: rgba(255, 69, 0, 0.7);
            border-radius: 50%;
            display: none;
            z-index: 200;
            box-shadow: 0 0 15px rgba(255, 69, 0, 0.7);
            border: 2px solid #8a2be2;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="gameArea">
        <div id="timer">00:00</div>
        <div id="extraLifeIcon"></div>
        <div id="explosionIcon"></div>
        <div id="player"></div>
        <div id="enemy" class="enemy enemy-purple"></div>
        <div id="enemy2" class="enemy enemy-green"></div>
        <div id="gameOver">
            <h2>Fim de Jogo!</h2>
            <p>Sua sobrevivência: <span id="tempoFinal">00:00</span></p>
            <button onclick="voltarTelaInicial()">Voltar ao Menu</button>
        </div>
        <div id="telaInicial">
            <h1>Geometryc Runner</h1>
            <div class="menu-button" onclick="iniciarNovoJogo()">Iniciar Aventura</div>
            <div class="menu-button" onclick="verRanking()">Hall da Fama</div>
            <div class="menu-button" onclick="abrirLoja()">Arsenal</div>
            <div class="menu-button" onclick="abrirConfiguracao()">Configuração</div>
            <div class="menu-button" onclick="fazerDoacao()">Apoiar</div>
            <div id="pontuacoes" style="display: none;">
                <p id="ultimaPontuacao">Última sobrevivência: 00:00</p>
                <p id="melhorPontuacao">Melhor sobrevivência: 00:00</p>
            </div>
        </div>
        <div id="telaRanking">
            <h2>Hall da Fama</h2>
            <div id="rankingList">
                <!-- Ranking será preenchido dinamicamente -->
            </div>
            <div class="menu-button" onclick="voltarTelaInicial()">Voltar ao Menu</div>
        </div>
        <div id="nickForm">
            <h3>Impressionante!</h3>
            <p>Sua sobrevivência: <span id="tempoNick">00:00</span></p>
            <p>Digite seu nome para o Hall da Fama:</p>
            <input type="text" id="playerNick" maxlength="15" placeholder="Seu nome">
            <button onclick="salvarNick()">Registrar</button>
        </div>
        <div id="telaConfiguracao">
            <h2>Configuração</h2>
            <div id="configForm">
                <label for="playerNickConfig">Seu nome:</label>
                <input type="text" id="playerNickConfig" maxlength="15" placeholder="Seu nome">
                <button onclick="salvarConfiguracao()">Salvar</button>
            </div>
            <div class="menu-button" onclick="voltarTelaInicial()">Voltar ao Menu</div>
        </div>
        <div id="telaPerks">
            <h2>Escolha um Perk</h2>
            <div class="perk-button" onclick="escolherPerk('extraLife')">Vida Extra</div>
            <div class="perk-button" onclick="escolherPerk('speedBoost')">Aumentar Velocidade</div>
            <div class="perk-button" onclick="escolherPerk('explosion')">Explosão</div>
        </div>
        <div id="telaLoja">
            <h2>Arsenal</h2>
            <div class="label">PLAYER</div>
            <div class="color-picker">
                <div class="color-option" onclick="alterarCorPersonagem('#c17aff', '#8a2be2')"></div>
                <div class="color-option" style="background: radial-gradient(circle at 30% 30%, #ff79c6, #bd93f9);" onclick="alterarCorPersonagem('#ff79c6', '#bd93f9')"></div>
                <div class="color-option" style="background: radial-gradient(circle at 30% 30%, #50fa7b, #00b894);" onclick="alterarCorPersonagem('#50fa7b', '#00b894')"></div>
            </div>
            <div class="label">BACKGROUND</div>
            <div class="background-picker">
                <div class="background-option" onclick="alterarBackground('linear-gradient(45deg, #0a0a0a, #1a1a1a)')"></div>
                <div class="background-option" style="background: linear-gradient(45deg, #1a1a1a, #0a0a0a);" onclick="alterarBackground('linear-gradient(45deg, #1a1a1a, #0a0a0a)')"></div>
                <div class="background-option" style="background: linear-gradient(45deg, #0a0a0a, #2a2a2a);" onclick="alterarBackground('linear-gradient(45deg, #0a0a0a, #2a2a2a)')"></div>
            </div>
            <div class="menu-button" onclick="voltarTelaInicial()">Voltar ao Menu</div>
        </div>
        <div id="mobileCursor"></div>
        <div id="explosionButton" onclick="usarExplosao()"></div>
    </div>
    <script>
        function alterarCorPersonagem(cor1, cor2) {
            const player = document.getElementById('player');
            player.style.background = `radial-gradient(circle at 30% 30%, ${cor1}, ${cor2})`;
        }

        function alterarBackground(background) {
            const gameArea = document.getElementById('gameArea');
            gameArea.style.background = background;
        }

        function abrirLoja() {
            document.getElementById('telaLoja').style.display = 'flex';
            document.getElementById('telaInicial').style.display = 'none';
        }

        function voltarTelaInicial() {
            document.getElementById('telaLoja').style.display = 'none';
            document.getElementById('telaInicial').style.display = 'flex';
        }

        function usarExplosao() {
            if (explosionAvailable) {
                criarExplosao(playerPos.x + 15, playerPos.y + 15);
                explosionAvailable = false;
                explosionIcon.style.display = 'none';
            }
        }

        function detectarMobile() {
            const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
            if (isMobile) {
                document.getElementById('mobileCursor').style.display = 'block';
                document.getElementById('explosionButton').style.display = 'block';
                screen.orientation.lock('landscape');
            }
        }

        window.addEventListener('load', detectarMobile);

        const player = document.getElementById('player');
        const enemy = document.getElementById('enemy');
        const enemy2 = document.getElementById('enemy2');
        const gameArea = document.getElementById('gameArea');
        const gameOver = document.getElementById('gameOver');
        const timerElement = document.getElementById('timer');
        const tempoFinalElement = document.getElementById('tempoFinal');
        const telaInicial = document.getElementById('telaInicial');
        const ultimaPontuacaoElement = document.getElementById('ultimaPontuacao');
        const melhorPontuacaoElement = document.getElementById('melhorPontuacao');
        const pontuacoesDiv = document.getElementById('pontuacoes');
        const telaRanking = document.getElementById('telaRanking');
        const rankingList = document.getElementById('rankingList');
        const nickForm = document.getElementById('nickForm');
        const tempoNickElement = document.getElementById('tempoNick');
        const playerNickInput = document.getElementById('playerNick');
        const telaConfiguracao = document.getElementById('telaConfiguracao');
        const playerNickConfig = document.getElementById('playerNickConfig');
        const telaPerks = document.getElementById('telaPerks');
        const extraLifeIcon = document.getElementById('extraLifeIcon');
        const explosionIcon = document.getElementById('explosionIcon');
        const mobileCursor = document.getElementById('mobileCursor');
        
        let startTime;
        let playerPos = { x: window.innerWidth/2, y: window.innerHeight/2 };
        let enemyPos = { x: 50, y: 50 };
        let enemy2Pos = { x: window.innerWidth - 80, y: window.innerHeight - 80 };
        let playerSpeed = 7;
        const enemySpeed = 4;
        const enemy2Speed = 3;
        const obstacles = [];
        let gameLoop;
        let teclasPressionadas = {};
        let obstacleMovementInterval;
        let navMeshPoints = [];
        let timerInterval;
        let spawnInterval;
        let perkInterval;
        let enemies = [
            {element: enemy, pos: enemyPos, speed: enemySpeed, type: 'purple', direcao: Math.random() * 2 * Math.PI},
            {element: enemy2, pos: enemy2Pos, speed: enemy2Speed, type: 'green'}
        ];
        // Variável para controlar o número máximo de inimigos
        const MAX_ENEMIES = 100;
        // Variável para limitar a frequência de geração de navMesh
        let lastNavMeshUpdate = 0;
        const NAV_MESH_UPDATE_INTERVAL = 1000; // 1 segundo
        // Variáveis para armazenar pontuações
        let ultimaPontuacao = "00:00";
        let melhorPontuacao = "00:00";
        let jogoEmAndamento = false;
        // Array para armazenar o ranking
        let ranking = [];
        // Tempo atual para salvar no ranking
        let tempoAtual = "00:00";
        // Nome do jogador
        let playerName = "";
        // Variável para controlar se o jogador está em uma área de desaceleração
        let playerInSlowArea = false;
        // Velocidade normal do jogador (para restaurar após sair da área de desaceleração)
        const normalPlayerSpeed = 7;
        // Velocidade reduzida quando em área de desaceleração
        const slowedPlayerSpeed = 3;
        // Variável para controlar o efeito de lentidão do inimigo azul
        let playerSlowedByBlueEnemy = false;
        let playerSlowTimer = null;
        // Variáveis para controlar os perks
        let extraLife = false;
        let speedBoost = false;
        let explosionAvailable = false;
        // Variável para controlar o tempo de jogo
        let tempoDecorrido = 0;

        // Verificar se o jogador já tem um nome salvo
        function verificarNomeJogador() {
            const nomeSalvo = localStorage.getItem('playerName');
            if (nomeSalvo) {
                playerName = nomeSalvo;
            } else {
                // Se não tiver nome salvo, solicitar na primeira vez
                solicitarNomeJogador();
            }
        }

        function solicitarNomeJogador() {
            const nome = prompt("Bem-vindo! Como devemos chamá-lo?", "Jogador") || "Jogador";
            playerName = nome.substring(0, 15); // Limitar a 15 caracteres
            localStorage.setItem('playerName', playerName);
        }

        // Funções para a tela de configuração
        function abrirConfiguracao() {
            telaInicial.style.display = 'none';
            telaConfiguracao.style.display = 'flex';
            playerNickConfig.value = playerName;
        }

        function salvarConfiguracao() {
            const novoNome = playerNickConfig.value.trim() || "Jogador";
            playerName = novoNome.substring(0, 15); // Limitar a 15 caracteres
            localStorage.setItem('playerName', playerName);
            voltarTelaInicial();
        }

        // Funções para a tela inicial
        function iniciarNovoJogo() {
            telaInicial.style.display = 'none';
            telaRanking.style.display = 'none';
            telaConfiguracao.style.display = 'none';
            pontuacoesDiv.style.display = 'none';
            reiniciarJogo();
            jogoEmAndamento = true;
        }

        function verRanking() {
            telaInicial.style.display = 'none';
            telaRanking.style.display = 'flex';
            atualizarTelaRanking();
        }

        async function atualizarTelaRanking() {
            // Limpar lista atual
            rankingList.innerHTML = '';
            
            // Carregar ranking do JSON
            await carregarRanking();
            
            // Exibir os 10 melhores
            const top10 = ranking.slice(0, 10);
            
            if (top10.length === 0) {
                rankingList.innerHTML = '<div class="ranking-item">Nenhuma pontuação registrada ainda</div>';
            } else {
                top10.forEach((item, index) => {
                    const rankingItem = document.createElement('div');
                    rankingItem.className = 'ranking-item';
                    
                    const position = document.createElement('div');
                    position.className = 'ranking-position';
                    position.textContent = `${index + 1}.`;
                    
                    const nick = document.createElement('div');
                    nick.className = 'ranking-nick';
                    nick.textContent = item.nick;
                    
                    const tempo = document.createElement('div');
                    tempo.className = 'ranking-tempo';
                    tempo.textContent = item.tempo;
                    
                    rankingItem.appendChild(position);
                    rankingItem.appendChild(nick);
                    rankingItem.appendChild(tempo);
                    
                    rankingList.appendChild(rankingItem);
                });
            }
        }

        function abrirLoja() {
            document.getElementById('telaLoja').style.display = 'flex';
            document.getElementById('telaInicial').style.display = 'none';
        }

        function fazerDoacao() {
            alert("Funcionalidade de doação em desenvolvimento!");
        }

        function voltarTelaInicial() {
            gameOver.style.display = 'none';
            telaRanking.style.display = 'none';
            telaConfiguracao.style.display = 'none';
            telaInicial.style.display = 'flex';
            pontuacoesDiv.style.display = 'block';
            document.getElementById('telaLoja').style.display = 'none';
            jogoEmAndamento = false;
            
            // Parar todos os loops e intervalos do jogo
            pararJogo();
            
            // Atualizar e mostrar as pontuações
            atualizarPontuacoes();
        }

        function atualizarPontuacoes() {
            ultimaPontuacaoElement.textContent = `Última sobrevivência: ${ultimaPontuacao}`;
            melhorPontuacaoElement.textContent = `Melhor sobrevivência: ${melhorPontuacao}`;
        }

        // Funções para manipular cookies
        function setCookie(nome, valor, dias) {
            const data = new Date();
            data.setTime(data.getTime() + (dias * 24 * 60 * 60 * 1000));
            const expira = `expires=${data.toUTCString()}`;
            document.cookie = `${nome}=${valor};${expira};path=/`;
        }

        function getCookie(nome) {
            const nomeCookie = `${nome}=`;
            const cookies = document.cookie.split(';');
            for(let i = 0; i < cookies.length; i++) {
                let cookie = cookies[i].trim();
                if (cookie.indexOf(nomeCookie) === 0) {
                    return cookie.substring(nomeCookie.length, cookie.length);
                }
            }
            return "";
        }

        async function salvarPontuacao(tempo) {
            ultimaPontuacao = tempo;
            setCookie("ultimaPontuacao", tempo, 30);
            tempoAtual = tempo;
            
            // Verificar se é a melhor pontuação
            const melhorSalva = getCookie("melhorPontuacao");
            if (melhorSalva === "" || compararTempos(tempo, melhorSalva)) {
                melhorPontuacao = tempo;
                setCookie("melhorPontuacao", tempo, 30);
                
                // Adicionar ao ranking apenas se for a melhor pontuação ou a primeira
                await adicionarAoRanking(playerName, tempoAtual);
            } else {
                melhorPontuacao = melhorSalva;
            }
            
            // Mostrar tela de fim de jogo
            gameOver.style.display = 'block';
        }
        
        function mostrarFormularioNick(tempo) {
            tempoNickElement.textContent = tempo;
            nickForm.style.display = 'block';
            playerNickInput.value = playerName;
            playerNickInput.maxLength = 15; // Limitar a 15 caracteres
            playerNickInput.focus();
        }
        
        async function salvarNick() {
            const nick = playerNickInput.value.trim() || "Anônimo";
            playerName = nick.substring(0, 15);
            localStorage.setItem('playerName', playerName);
            
            // Verificar se o tempo atual é melhor que o melhor tempo salvo
            const melhorSalva = getCookie("melhorPontuacao");
            if (melhorSalva === "" || compararTempos(tempoAtual, melhorSalva)) {
                // Adicionar ao ranking apenas se for a melhor pontuação ou a primeira
                await adicionarAoRanking(playerName, tempoAtual);
            }
            
            // Fechar formulário
            nickForm.style.display = 'none';
            
            // Mostrar ranking
            verRanking();
        }
        
        async function adicionarAoRanking(nick, tempo) {
            // Carregar ranking atual
            await carregarRanking();
            
            // Verificar se o jogador já tem uma entrada no ranking
            const indiceJogador = ranking.findIndex(item => item.nick === nick);
            
            if (indiceJogador !== -1) {
                // Se o jogador já existe no ranking, atualizar apenas se o tempo for melhor
                if (compararTempos(tempo, ranking[indiceJogador].tempo)) {
                    ranking[indiceJogador].tempo = tempo;
                }
            } else {
                // Se o jogador não existe no ranking, adicionar nova entrada
                ranking.push({
                    nick: nick,
                    tempo: tempo
                });
            }
            
            // Ordenar ranking (tempos maiores são melhores)
            ranking.sort((a, b) => {
                return compararTempos(a.tempo, b.tempo) ? -1 : 1;
            });
            
            // Manter apenas os 10 melhores
            ranking = ranking.slice(0, 10);
            
            // Salvar ranking atualizado
            await salvarRanking();
        }
        
        async function carregarRanking() {
            try {
                const response = await fetch('ranking.json');
                if (response.ok) {
                    ranking = await response.json();
                } else {
                    ranking = [];
                }
            } catch (error) {
                console.error('Erro ao carregar o ranking:', error);
                ranking = [];
            }
        }
        
        async function salvarRanking() {
            try {
                const response = await fetch('saveRanking', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(ranking)
                });
                if (!response.ok) {
                    throw new Error('Erro ao salvar o ranking');
                }
            } catch (error) {
                console.error('Erro ao salvar o ranking:', error);
            }
        }

        function compararTempos(tempo1, tempo2) {
            // Converter tempos no formato "MM:SS" para segundos
            const [min1, seg1] = tempo1.split(':').map(Number);
            const [min2, seg2] = tempo2.split(':').map(Number);
            
            const totalSeg1 = min1 * 60 + seg1;
            const totalSeg2 = min2 * 60 + seg2;
            
            // Retorna true se tempo1 for maior (melhor) que tempo2
            return totalSeg1 > totalSeg2;
        }

        function carregarPontuacoes() {
            const ultimaSalva = getCookie("ultimaPontuacao");
            const melhorSalva = getCookie("melhorPontuacao");
            
            if (ultimaSalva !== "") {
                ultimaPontuacao = ultimaSalva;
            }
            
            if (melhorSalva !== "") {
                melhorPontuacao = melhorSalva;
            }
            
            atualizarPontuacoes();
        }

        function criarNovoInimigo() {
            // Limitar o número máximo de inimigos para evitar sobrecarga
            if (enemies.length >= MAX_ENEMIES) return;
            
            // Determinar o tipo de inimigo a ser criado (incluindo o amarelo, azul e laranja)
            const random = Math.random();
            let tipoInimigo;

            switch (true) {
                case (random < 0.15):
                    // 10% de chance de criar inimigo amarelo
                    return criarInimigoAmarelo(); // Retornar aqui pois criarInimigoAmarelo já adiciona à lista
                case (random < 0.25):
                    // 10% de chance de criar inimigo azul (gelo)
                    return criarInimigoAzul(); // Retornar aqui pois criarInimigoAzul já adiciona à lista
                case (random < 0.35):
                    // 10% de chance de criar inimigo laranja (teleportador)
                    return criarInimigoLaranja(); // Retornar aqui pois criarInimigoLaranja já adiciona à lista
                case (random < 0.55):
                    // 30% de chance de criar inimigo roxo
                    tipoInimigo = 'purple';
                    break;
                default:
                    // 30% de chance de criar inimigo verde
                    tipoInimigo = 'green';
            }
            const velocidadeBase = tipoInimigo === 'purple' ? enemySpeed : enemy2Speed;
            // Adicionar aleatoriedade à velocidade (até 50% a mais)
            const fatorVelocidade = 1 + Math.random() * 0.5;
            const velocidadeFinal = velocidadeBase * fatorVelocidade;
            
            const novoInimigo = document.createElement('div');
            novoInimigo.className = `enemy enemy-${tipoInimigo}`;
            gameArea.appendChild(novoInimigo);

            // Limitar tentativas de posicionamento para evitar loops infinitos
            let tentativas = 0;
            let pos;
            do {
                pos = {
                    x: Math.random() * (window.innerWidth - 30),
                    y: Math.random() * (window.innerHeight - 30)
                };
                tentativas++;
                if (tentativas > 50) return; // Desistir após muitas tentativas
            } while(checkCollision(pos.x, pos.y) || checkEnemyCollision(pos.x, pos.y));

            enemies.push({
                element: novoInimigo,
                pos: pos,
                speed: velocidadeFinal,
                type: tipoInimigo,
                direcao: tipoInimigo === 'purple' ? Math.random() * 2 * Math.PI : null,
                // Adicionar um offset aleatório para cada inimigo
                offset: {
                    x: Math.random() * 100 - 50,
                    y: Math.random() * 100 - 50
                }
            });
        }
        
        function criarInimigoAzul() {
            // Criar inimigo azul (gelo)
            const inimigoAzul = document.createElement('div');
            inimigoAzul.className = 'enemy enemy-blue';
            gameArea.appendChild(inimigoAzul);
            
            // Encontrar uma posição válida para o inimigo azul
            let tentativas = 0;
            let pos;
            do {
                pos = {
                    x: Math.random() * (window.innerWidth - 30),
                    y: Math.random() * (window.innerHeight - 30)
                };
                tentativas++;
                if (tentativas > 50) return null; // Desistir após muitas tentativas
            } while(checkCollision(pos.x, pos.y) || checkEnemyCollision(pos.x, pos.y));
            
            const novoInimigo = {
                element: inimigoAzul,
                pos: pos,
                speed: 6, // Inimigo azul se move lentamente
                type: 'blue',
                congelou: false // Flag para controlar se já congelou o jogador
            };
            
            enemies.push(novoInimigo);
            
            // Atualizar a posição do elemento
            inimigoAzul.style.left = pos.x + 'px';
            inimigoAzul.style.top = pos.y + 'px';
            
            return novoInimigo;
        }
        
        // Função para aplicar o efeito de congelamento quando o jogador tocar no inimigo azul
        function aplicarEfeitoCongelamento(inimigoAzul) {
            if (inimigoAzul.congelou) return; // Evitar aplicar o efeito mais de uma vez
            
            inimigoAzul.congelou = true;
            
            // Guardar a velocidade original do jogador
            const velocidadeOriginal = playerSpeed;
            
            // Reduzir a velocidade do jogador em 25%
            playerSpeed *= 0.75;
            
            // Adicionar efeito visual ao jogador
            player.classList.add('congelado');
            
            // Remover o inimigo azul
            const index = enemies.findIndex(e => e === inimigoAzul);
            if (index !== -1) {
                gameArea.removeChild(inimigoAzul.element);
                enemies.splice(index, 1);
            }
            
            // Restaurar a velocidade normal após 5 segundos
            setTimeout(() => {
                playerSpeed = velocidadeOriginal;
                player.classList.remove('congelado');
            }, 5000);
        }
        
        function criarInimigoAmarelo() {
            // Criar inimigo amarelo (bomba)
            const inimigoAmarelo = document.createElement('div');
            inimigoAmarelo.className = 'enemy enemy-yellow';
            gameArea.appendChild(inimigoAmarelo);
            
            // Encontrar uma posição válida para o inimigo amarelo
            let tentativas = 0;
            let pos;
            do {
                pos = {
                    x: Math.random() * (window.innerWidth - 30),
                    y: Math.random() * (window.innerHeight - 30)
                };
                tentativas++;
                if (tentativas > 50) return null; // Desistir após muitas tentativas
            } while(checkCollision(pos.x, pos.y) || checkEnemyCollision(pos.x, pos.y));
            
            const novoInimigo = {
                element: inimigoAmarelo,
                pos: pos,
                speed: 0, // Inimigo amarelo não se move
                type: 'yellow',
                tempoParaExplodir: 10000, // 10 segundos para explodir
                inicioPiscando: false
            };
            
            enemies.push(novoInimigo);
            
            // Atualizar a posição do elemento
            inimigoAmarelo.style.left = pos.x + 'px';
            inimigoAmarelo.style.top = pos.y + 'px';
            
            // Iniciar contagem regressiva para explosão
            setTimeout(() => {
                if (novoInimigo.element && novoInimigo.element.parentNode) {
                    // Começar a piscar após 5 segundos
                    novoInimigo.inicioPiscando = true;
                    novoInimigo.element.classList.add('piscando');
                    
                    // Explodir após mais 5 segundos
                    setTimeout(() => {
                        if (novoInimigo.element && novoInimigo.element.parentNode) {
                            explodir(novoInimigo);
                        }
                    }, 5000);
                }
            }, 5000);
            
            return novoInimigo;
        }
        
        function criarInimigoLaranja() {
            // Criar inimigo laranja (teleportador)
            const inimigoLaranja = document.createElement('div');
            inimigoLaranja.className = 'enemy enemy-orange';
            gameArea.appendChild(inimigoLaranja);
            
            // Encontrar uma posição válida para o inimigo laranja
            let tentativas = 0;
            let pos;
            do {
                pos = {
                    x: Math.random() * (window.innerWidth - 30),
                    y: Math.random() * (window.innerHeight - 30)
                };
                tentativas++;
                if (tentativas > 50) return null; // Desistir após muitas tentativas
            } while(checkCollision(pos.x, pos.y) || checkEnemyCollision(pos.x, pos.y));
            
            const novoInimigo = {
                element: inimigoLaranja,
                pos: pos,
                speed: 5, // Inimigo laranja se move rapidamente
                type: 'orange',
                teleportar: true // Flag para controlar se deve teleportar
            };
            
            enemies.push(novoInimigo);
            
            // Atualizar a posição do elemento
            inimigoLaranja.style.left = pos.x + 'px';
            inimigoLaranja.style.top = pos.y + 'px';
            
            // Iniciar teleporte a cada 3 segundos
            setInterval(() => {
                if (novoInimigo.teleportar) {
                    teleportarInimigo(novoInimigo);
                }
            }, 3000);
            
            return novoInimigo;
        }
        
        function teleportarInimigo(inimigoLaranja) {
            // Encontrar uma nova posição válida para o inimigo laranja
            let tentativas = 0;
            let novaPos;
            do {
                novaPos = {
                    x: Math.random() * (window.innerWidth - 30),
                    y: Math.random() * (window.innerHeight - 30)
                };
                tentativas++;
                if (tentativas > 50) return; // Desistir após muitas tentativas
            } while(checkCollision(novaPos.x, novaPos.y) || checkEnemyCollision(novaPos.x, novaPos.y));
            
            // Atualizar a posição do inimigo laranja
            inimigoLaranja.pos = novaPos;
            inimigoLaranja.element.style.left = novaPos.x + 'px';
            inimigoLaranja.element.style.top = novaPos.y + 'px';
        }
        
        function explodir(inimigoAmarelo) {
            // Raio da explosão aumentado
            const raioExplosao = 180; // Aumentado de 150 para 180
            
            // Criar efeito visual de explosão grande
            const explosao = document.createElement('div');
            explosao.className = 'explosion';
            explosao.style.width = (raioExplosao * 2) + 'px';
            explosao.style.height = (raioExplosao * 2) + 'px';
            explosao.style.left = (inimigoAmarelo.pos.x - raioExplosao + 15) + 'px'; // Centralizar a explosão
            explosao.style.top = (inimigoAmarelo.pos.y - raioExplosao + 15) + 'px';
            gameArea.appendChild(explosao);
            
            // Verificar se o jogador está dentro do raio da explosão
            const distanciaAoJogador = Math.sqrt(
                Math.pow(playerPos.x + 15 - (inimigoAmarelo.pos.x + 15), 2) + 
                Math.pow(playerPos.y + 15 - (inimigoAmarelo.pos.y + 15), 2)
            );
            
            if (distanciaAoJogador <= raioExplosao) {
                // Jogador atingido pela explosão
                if (extraLife) {
                    extraLife = false;
                    extraLifeIcon.style.display = 'none';
                } else {
                    fimDeJogo();
                }
            }
            
            // Verificar quais inimigos estão dentro do raio da explosão
            const inimigosParaRemover = [];
            
            for (let i = 0; i < enemies.length; i++) {
                const enemy = enemies[i];
                if (enemy === inimigoAmarelo) continue; // Pular o próprio inimigo amarelo
                
                const distancia = Math.sqrt(
                    Math.pow(enemy.pos.x + 15 - (inimigoAmarelo.pos.x + 15), 2) + 
                    Math.pow(enemy.pos.y + 15 - (inimigoAmarelo.pos.y + 15), 2)
                );
                
                if (distancia <= raioExplosao) {
                    inimigosParaRemover.push(i);
                }
            }
            
            // Remover inimigos atingidos pela explosão (de trás para frente para não afetar os índices)
            for (let i = inimigosParaRemover.length - 1; i >= 0; i--) {
                const indice = inimigosParaRemover[i];
                if (enemies[indice] && enemies[indice].element) {
                    enemies[indice].element.remove();
                    enemies.splice(indice, 1);
                }
            }
            
            // Remover o inimigo amarelo que explodiu
            const indiceAmarelo = enemies.indexOf(inimigoAmarelo);
            if (indiceAmarelo !== -1) {
                enemies.splice(indiceAmarelo, 1);
            }
            inimigoAmarelo.element.remove();
            
            // Remover a explosão após a animação terminar
            setTimeout(() => {
                if (explosao.parentNode) {
                    explosao.remove();
                }
            }, 500);
        }
        
        function criarExplosao(x, y) {
            const explosao = document.createElement('div');
            explosao.className = 'explosion';
            
            // Calcular o tamanho da explosão como 60% da menor dimensão da tela
            const raioExplosao = Math.min(window.innerWidth, window.innerHeight) * 0.6;
            explosao.style.width = `${raioExplosao}px`;
            explosao.style.height = `${raioExplosao}px`;
            
            explosao.style.backgroundColor = 'orange';
            explosao.style.borderRadius = '50%';
            explosao.style.position = 'absolute';
            explosao.style.zIndex = '200';
            explosao.style.animation = 'explode 0.5s forwards';
            explosao.style.left = (x - raioExplosao / 2) + 'px'; // Centralizar a explosão
            explosao.style.top = (y - raioExplosao / 2) + 'px';
            gameArea.appendChild(explosao);
            
            // Eliminar todos os inimigos dentro do raio da explosão
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const distancia = Math.sqrt(
                    Math.pow(enemy.pos.x + 15 - x, 2) + 
                    Math.pow(enemy.pos.y + 15 - y, 2)
                );
                
                if (distancia <= raioExplosao) {
                    if (enemy && enemy.element) {
                        enemy.element.remove();
                        enemies.splice(i, 1);
                    }
                }
            }
            
            // Adicionar estilo de animação se não existir
            if (!document.getElementById('explosionAnimation')) {
                const style = document.createElement('style');
                style.id = 'explosionAnimation';
                style.innerHTML = `
                    @keyframes explode {
                        0% { transform: scale(0.1); opacity: 1; }
                        100% { transform: scale(2); opacity: 0; }
                    }
                `;
                document.head.appendChild(style);
            }
            
            // Remover a explosão após a animação terminar
            setTimeout(() => {
                if (explosao.parentNode) {
                    explosao.remove();
                }
            }, 500);
        }

        function atualizarTimer() {
            if (telaPerks.style.display === 'flex') return; // Pausar o timer se a tela de perks estiver visível

            const tempoDecorrido = Math.floor((Date.now() - startTime) / 1000);
            const minutos = Math.floor(tempoDecorrido / 60);
            const segundos = tempoDecorrido % 60;
            timerElement.textContent = `${minutos.toString().padStart(2, '0')}:${segundos.toString().padStart(2, '0')}`;
            
            // Mostrar tela de perks a cada múltiplo de 60 segundos
            if (tempoDecorrido > 0 && tempoDecorrido % 60 === 0) {
                mostrarTelaPerks();
            }
        }

        function gerarNavMeshPoints() {
            // Verificar se já passou tempo suficiente desde a última atualização
            const agora = Date.now();
            if (agora - lastNavMeshUpdate < NAV_MESH_UPDATE_INTERVAL) return;
            lastNavMeshUpdate = agora;
            
            navMeshPoints = [];
            const gridSize = 30;
            // Limitar o número de pontos para evitar sobrecarga
            const maxPoints = 200;
            let pointCount = 0;
            
            for(let x = 0; x < window.innerWidth; x += gridSize) {
                if (pointCount >= maxPoints) break;
                
                for(let y = 0; y < window.innerHeight; y += gridSize) {
                    if (pointCount >= maxPoints) break;
                    
                    if(!checkCollision(x, y) && !checkEnemyCollision(x, y)) {
                        let pontoValido = true;
                        
                        // Simplificar a verificação para melhorar performance
                        for(let dx = -gridSize; dx <= gridSize; dx += gridSize) {
                            for(let dy = -gridSize; dy <= gridSize; dy += gridSize) {
                                if(checkCollision(x + dx, y + dy)) {
                                    pontoValido = false;
                                    break;
                                }
                            }
                            if(!pontoValido) break;
                        }
                        
                        if(pontoValido) {
                            navMeshPoints.push({x, y, f: 0, g: 0, h: 0, parent: null});
                            pointCount++;
                        }
                    }
                }
            }
        }

        function encontrarProximoPonto(posAtual) {
            // Se não houver pontos de navegação, retornar a posição do jogador
            if (navMeshPoints.length === 0) return playerPos;
            
            let pontoMaisProximo = null;
            let menorDistancia = Infinity;

            // Simplificar para apenas encontrar o ponto mais próximo ao jogador
            // em vez de usar A* completo, que pode ser pesado
            for (let ponto of navMeshPoints) {
                const distAoJogador = Math.sqrt(
                    Math.pow(playerPos.x - ponto.x, 2) + 
                    Math.pow(playerPos.y - ponto.y, 2)
                );
                
                if (distAoJogador < menorDistancia) {
                    menorDistancia = distAoJogador;
                    pontoMaisProximo = ponto;
                }
            }
            
            return pontoMaisProximo || playerPos;
        }

        function criarObstaculos() {
            const numObstacles = Math.min(15, Math.floor(window.innerWidth * window.innerHeight / 50000));
            
            for(let i = 0; i < numObstacles; i++) {
                const pos = {
                    x: Math.random() * (window.innerWidth - 50),
                    y: Math.random() * (window.innerHeight - 50)
                };
                
                const obstacle = document.createElement('div');
                obstacle.className = 'obstacle';
                obstacle.style.left = pos.x + 'px';
                obstacle.style.top = pos.y + 'px';
                obstacle.style.transform = `rotate(${Math.random() * 360}deg)`;
                gameArea.appendChild(obstacle);
                
                obstacles.push({
                    element: obstacle,
                    x: pos.x,
                    y: pos.y,
                    width: 50,
                    height: 50,
                    velocidadeX: (Math.random() - 0.5) * 2,
                    velocidadeY: (Math.random() - 0.5) * 2
                });
            }
            
            gerarNavMeshPoints();
        }

        function moverObstaculos() {
            obstacles.forEach(obstacle => {
                const novoX = obstacle.x + obstacle.velocidadeX;
                const novoY = obstacle.y + obstacle.velocidadeY;

                // Verificar se o novo movimento do obstáculo não colide com inimigos
                if(!checkEnemyCollision(novoX, novoY)) {
                    // Verificar se o jogador não está no caminho do obstáculo
                    const playerRect = {
                        x: playerPos.x,
                        y: playerPos.y,
                        width: 30,
                        height: 30
                    };
                    
                    const obstacleRect = {
                        x: novoX,
                        y: novoY,
                        width: 50,
                        height: 50
                    };
                    
                    if (!(playerRect.x < obstacleRect.x + obstacleRect.width &&
                        playerRect.x + playerRect.width > obstacleRect.x &&
                        playerRect.y < obstacleRect.y + obstacleRect.height &&
                        playerRect.y + playerRect.height > obstacleRect.y)) {
                        
                        obstacle.x = novoX;
                        obstacle.y = novoY;

                        if(obstacle.x <= 0 || obstacle.x >= window.innerWidth - 50) {
                            obstacle.velocidadeX *= -1;
                        }
                        if(obstacle.y <= 0 || obstacle.y >= window.innerHeight - 50) {
                            obstacle.velocidadeY *= -1;
                        }

                        obstacle.element.style.left = obstacle.x + 'px';
                        obstacle.element.style.top = obstacle.y + 'px';
                        obstacle.element.style.transform = `rotate(${Date.now() / 50 % 360}deg)`;
                    } else {
                        // Se o jogador está no caminho, inverter a direção
                        obstacle.velocidadeX *= -1;
                        obstacle.velocidadeY *= -1;
                    }
                } else {
                    // Se há colisão com inimigos, inverter a direção
                    obstacle.velocidadeX *= -1;
                    obstacle.velocidadeY *= -1;
                }
            });
            
            // Verificar se algum obstáculo está colidindo com o jogador ou inimigos após o movimento
            verificarColisoesPosMovimento();
        }
        
        function verificarColisoesPosMovimento() {
            // Verificar colisões com o jogador
            for (let obstacle of obstacles) {
                if (playerPos.x < obstacle.x + obstacle.width &&
                    playerPos.x + 30 > obstacle.x &&
                    playerPos.y < obstacle.y + obstacle.height &&
                    playerPos.y + 30 > obstacle.y) {
                    
                    // Calcular a direção para empurrar o jogador para fora do obstáculo
                    const centroObstaculoX = obstacle.x + obstacle.width / 2;
                    const centroObstaculoY = obstacle.y + obstacle.height / 2;
                    const centroJogadorX = playerPos.x + 15;
                    const centroJogadorY = playerPos.y + 15;
                    
                    const direcaoX = centroJogadorX - centroObstaculoX;
                    const direcaoY = centroJogadorY - centroObstaculoY;
                    
                    // Normalizar a direção
                    const comprimento = Math.sqrt(direcaoX * direcaoX + direcaoY * direcaoY);
                    const normalX = direcaoX / comprimento;
                    const normalY = direcaoY / comprimento;
                    
                    // Empurrar o jogador para fora
                    playerPos.x += normalX * 5;
                    playerPos.y += normalY * 5;
                    
                    // Garantir que o jogador não saia da tela
                    playerPos.x = Math.max(0, Math.min(window.innerWidth - 30, playerPos.x));
                    playerPos.y = Math.max(0, Math.min(window.innerHeight - 30, playerPos.y));
                    
                    updatePlayerPosition();
                }
            }
            
            // Verificar colisões com os inimigos
            for (let enemy of enemies) {
                for (let obstacle of obstacles) {
                    if (enemy.pos.x < obstacle.x + obstacle.width &&
                        enemy.pos.x + 30 > obstacle.x &&
                        enemy.pos.y < obstacle.y + obstacle.height &&
                        enemy.pos.y + 30 > obstacle.y) {
                        
                        // Calcular a direção para empurrar o inimigo para fora do obstáculo
                        const centroObstaculoX = obstacle.x + obstacle.width / 2;
                        const centroObstaculoY = obstacle.y + obstacle.height / 2;
                        const centroInimigoX = enemy.pos.x + 15;
                        const centroInimigoY = enemy.pos.y + 15;
                        
                        const direcaoX = centroInimigoX - centroObstaculoX;
                        const direcaoY = centroInimigoY - centroObstaculoY;
                        
                        // Normalizar a direção
                        const comprimento = Math.sqrt(direcaoX * direcaoX + direcaoY * direcaoY);
                        if (comprimento > 0) { // Evitar divisão por zero
                            const normalX = direcaoX / comprimento;
                            const normalY = direcaoY / comprimento;
                            
                            // Empurrar o inimigo para fora
                            enemy.pos.x += normalX * 5;
                            enemy.pos.y += normalY * 5;
                            
                            // Garantir que o inimigo não saia da tela
                            enemy.pos.x = Math.max(0, Math.min(window.innerWidth - 30, enemy.pos.x));
                            enemy.pos.y = Math.max(0, Math.min(window.innerHeight - 30, enemy.pos.y));
                            
                            // Se for inimigo roxo, mudar sua direção
                            if (enemy.type === 'purple') {
                                enemy.direcao = Math.atan2(normalY, normalX);
                            }
                        }
                    }
                }
            }
            
            // Verificar colisões entre inimigos e separá-los
            resolverColisoesEntreInimigos();
            
            updateEnemyPosition();
        }
        
        function resolverColisoesEntreInimigos() {
            for (let i = 0; i < enemies.length; i++) {
                for (let j = i + 1; j < enemies.length; j++) {
                    const enemy1 = enemies[i];
                    const enemy2 = enemies[j];
                    
                    // Calcular distância entre os centros dos inimigos
                    const dx = enemy1.pos.x + 15 - (enemy2.pos.x + 15);
                    const dy = enemy1.pos.y + 15 - (enemy2.pos.y + 15);
                    const distancia = Math.sqrt(dx * dx + dy * dy);
                    
                    // Se estiverem colidindo (distância menor que a soma dos raios)
                    if (distancia < 30) { // 30 = 15 + 15 (raio de cada inimigo)
                        // Calcular vetor de separação normalizado
                        let separacaoX = dx;
                        let separacaoY = dy;
                        
                        // Evitar divisão por zero
                        if (distancia > 0) {
                            separacaoX /= distancia;
                            separacaoY /= distancia;
                        } else {
                            // Se a distância for zero (estão exatamente no mesmo lugar)
                            // Mover em uma direção aleatória
                            const angulo = Math.random() * 2 * Math.PI;
                            separacaoX = Math.cos(angulo);
                            separacaoY = Math.sin(angulo);
                        }
                        
                        // Calcular quanto eles precisam se mover para não colidirem
                        const sobreposicao = 30 - distancia;
                        
                        // Mover cada inimigo na direção oposta proporcionalmente à sua velocidade
                        const totalSpeed = enemy1.speed + enemy2.speed;
                        const peso1 = enemy2.speed / totalSpeed;
                        const peso2 = enemy1.speed / totalSpeed;
                        
                        // Aplicar movimento de separação com um fator adicional para garantir que se separem bem
                        const fatorSeparacao = 1.5;
                        
                        // Mover o primeiro inimigo
                        enemy1.pos.x += separacaoX * sobreposicao * peso1 * fatorSeparacao;
                        enemy1.pos.y += separacaoY * sobreposicao * peso1 * fatorSeparacao;
                        
                        // Mover o segundo inimigo na direção oposta
                        enemy2.pos.x -= separacaoX * sobreposicao * peso2 * fatorSeparacao;
                        enemy2.pos.y -= separacaoY * sobreposicao * peso2 * fatorSeparacao;
                        
                        // Garantir que os inimigos não saiam da tela
                        enemy1.pos.x = Math.max(0, Math.min(window.innerWidth - 30, enemy1.pos.x));
                        enemy1.pos.y = Math.max(0, Math.min(window.innerHeight - 30, enemy1.pos.y));
                        enemy2.pos.x = Math.max(0, Math.min(window.innerWidth - 30, enemy2.pos.x));
                        enemy2.pos.y = Math.max(0, Math.min(window.innerHeight - 30, enemy2.pos.y));
                        
                        // Se forem inimigos roxos, atualizar suas direções
                        if (enemy1.type === 'purple') {
                            enemy1.direcao = Math.atan2(separacaoY, separacaoX);
                        }
                        if (enemy2.type === 'purple') {
                            enemy2.direcao = Math.atan2(-separacaoY, -separacaoX);
                        }
                        
                        // Para inimigos verdes, adicionar um pequeno desvio aleatório para evitar que fiquem presos
                        if (enemy1.type === 'green') {
                            const desvio = Math.random() * Math.PI / 4 - Math.PI / 8; // Desvio de até ±22.5 graus
                            const angulo = Math.atan2(separacaoY, separacaoX) + desvio;
                            enemy1.pos.x += Math.cos(angulo) * 2;
                            enemy1.pos.y += Math.sin(angulo) * 2;
                        }
                        if (enemy2.type === 'green') {
                            const desvio = Math.random() * Math.PI / 4 - Math.PI / 8;
                            const angulo = Math.atan2(-separacaoY, -separacaoX) + desvio;
                            enemy2.pos.x += Math.cos(angulo) * 2;
                            enemy2.pos.y += Math.sin(angulo) * 2;
                        }
                    }
                }
            }
        }

        function updatePlayerPosition() {
            player.style.left = playerPos.x + 'px';
            player.style.top = playerPos.y + 'px';
        }

        function updateEnemyPosition() {
            enemies.forEach(enemy => {
                enemy.element.style.left = enemy.pos.x + 'px';
                enemy.element.style.top = enemy.pos.y + 'px';
            });
        }

        function checkEnemyCollision(newX, newY, excludeEnemy = null) {
            const enemyRect = {
                x: newX,
                y: newY,
                width: 30,
                height: 30
            };

            for(let enemy of enemies) {
                if(enemy === excludeEnemy) continue;
                
                if(enemyRect.x < enemy.pos.x + 30 &&
                   enemyRect.x + enemyRect.width > enemy.pos.x &&
                   enemyRect.y < enemy.pos.y + 30 &&
                   enemyRect.y + enemyRect.height > enemy.pos.y) {
                    return true;
                }
            }
            return false;
        }

        function checkCollision(newX, newY) {
            const playerRect = {
                x: newX,
                y: newY,
                width: 30,
                height: 30
            };

            for (let obstacle of obstacles) {
                if (playerRect.x < obstacle.x + obstacle.width &&
                    playerRect.x + playerRect.width > obstacle.x &&
                    playerRect.y < obstacle.y + obstacle.height &&
                    playerRect.y + playerRect.height > obstacle.y) {
                    return true;
                }
            }
            return false;
        }

        function moverInimigoRoxo(enemy) {
            // Chance de mudar de direção aleatoriamente
            if (Math.random() < 0.02) {
                enemy.direcao = Math.random() * 2 * Math.PI;
            }
            
            let novoX = enemy.pos.x + Math.cos(enemy.direcao) * enemy.speed;
            let novoY = enemy.pos.y + Math.sin(enemy.direcao) * enemy.speed;
            
            // Verificar limites da tela
            if (novoX < 0 || novoX > window.innerWidth - 30 || 
                novoY < 0 || novoY > window.innerHeight - 30 || 
                checkCollision(novoX, novoY) || 
                checkEnemyCollision(novoX, novoY, enemy)) {
                
                // Mudar direção se encontrar obstáculo ou borda
                enemy.direcao = Math.random() * 2 * Math.PI;
                
                // Tentar novamente com nova direção
                novoX = enemy.pos.x + Math.cos(enemy.direcao) * enemy.speed;
                novoY = enemy.pos.y + Math.sin(enemy.direcao) * enemy.speed;
                
                // Se ainda houver colisão, não mover
                if (novoX < 0 || novoX > window.innerWidth - 30 || 
                    novoY < 0 || novoY > window.innerHeight - 30 || 
                    checkCollision(novoX, novoY) || 
                    checkEnemyCollision(novoX, novoY, enemy)) {
                    return;
                }
            }
            
            enemy.pos.x = novoX;
            enemy.pos.y = novoY;
        }

        function moverInimigoVerde(enemy) {
            // Adicionar offset ao alvo para evitar aglomeração
            if (!enemy.offset) {
                enemy.offset = {
                    x: Math.random() * 100 - 50,
                    y: Math.random() * 100 - 50
                };
            }
            
            // Atualizar o offset periodicamente
            if (Math.random() < 0.01) {
                enemy.offset.x = Math.random() * 100 - 50;
                enemy.offset.y = Math.random() * 100 - 50;
            }
            
            // Calcular direção para o jogador com offset
            const targetX = playerPos.x + enemy.offset.x;
            const targetY = playerPos.y + enemy.offset.y;
            
            const dx = targetX - enemy.pos.x;
            const dy = targetY - enemy.pos.y;
            const distancia = Math.sqrt(dx * dx + dy * dy);
            
            // Evitar divisão por zero
            if (distancia > 0) {
                const angulo = Math.atan2(dy, dx);
                let novoX = enemy.pos.x + Math.cos(angulo) * enemy.speed;
                let novoY = enemy.pos.y + Math.sin(angulo) * enemy.speed;

                // Verificar se o movimento direto é possível
                if (novoX >= 0 && novoX <= window.innerWidth - 30 && 
                    novoY >= 0 && novoY <= window.innerHeight - 30 && 
                    !checkCollision(novoX, novoY) && 
                    !checkEnemyCollision(novoX, novoY, enemy)) {
                    
                    // Movimento direto possível
                    enemy.pos.x = novoX;
                    enemy.pos.y = novoY;
                } else {
                    // Tentar encontrar um caminho alternativo
                    // Primeiro, tentar mover apenas em X ou apenas em Y
                    let moveuX = false;
                    let moveuY = false;
                    
                    // Tentar mover apenas em X
                    if (dx !== 0) {
                        const direcaoX = dx > 0 ? 1 : -1;
                        const novoXSomente = enemy.pos.x + direcaoX * enemy.speed;
                        
                        if (novoXSomente >= 0 && novoXSomente <= window.innerWidth - 30 && 
                            !checkCollision(novoXSomente, enemy.pos.y) && 
                            !checkEnemyCollision(novoXSomente, enemy.pos.y, enemy)) {
                            enemy.pos.x = novoXSomente;
                            moveuX = true;
                        }
                    }
                    
                    // Tentar mover apenas em Y
                    if (dy !== 0) {
                        const direcaoY = dy > 0 ? 1 : -1;
                        const novoYSomente = enemy.pos.y + direcaoY * enemy.speed;
                        
                        if (novoYSomente >= 0 && novoYSomente <= window.innerHeight - 30 && 
                            !checkCollision(enemy.pos.x, novoYSomente) && 
                            !checkEnemyCollision(enemy.pos.x, novoYSomente, enemy)) {
                            enemy.pos.y = novoYSomente;
                            moveuY = true;
                        }
                    }
                    
                    // Se não conseguiu mover em X nem em Y, tentar direções alternativas
                    if (!moveuX && !moveuY) {
                        // Tentar 8 direções diferentes para contornar obstáculos
                        const direcoes = [
                            { x: 1, y: 0 },   // direita
                            { x: 1, y: 1 },   // diagonal inferior direita
                            { x: 0, y: 1 },   // baixo
                            { x: -1, y: 1 },  // diagonal inferior esquerda
                            { x: -1, y: 0 },  // esquerda
                            { x: -1, y: -1 }, // diagonal superior esquerda
                            { x: 0, y: -1 },  // cima
                            { x: 1, y: -1 }   // diagonal superior direita
                        ];
                        
                        // Ordenar direções pela proximidade ao ângulo desejado
                        direcoes.sort((a, b) => {
                            const anguloA = Math.atan2(a.y, a.x);
                            const anguloB = Math.atan2(b.y, b.x);
                            return Math.abs(anguloA - angulo) - Math.abs(anguloB - angulo);
                        });
                        
                        // Tentar cada direção até encontrar uma válida
                        for (let dir of direcoes) {
                            const testX = enemy.pos.x + dir.x * enemy.speed;
                            const testY = enemy.pos.y + dir.y * enemy.speed;
                            
                            if (testX >= 0 && testX <= window.innerWidth - 30 && 
                                testY >= 0 && testY <= window.innerHeight - 30 && 
                                !checkCollision(testX, testY) && 
                                !checkEnemyCollision(testX, testY, enemy)) {
                                
                                enemy.pos.x = testX;
                                enemy.pos.y = testY;
                                break;
                            }
                        }
                    }
                }
            }
        }

        function moverInimigo() {
            for(let enemy of enemies) {
                if (!enemy || !enemy.pos) continue; // Proteção contra objetos inválidos
                
                const dx = playerPos.x - enemy.pos.x;
                const dy = playerPos.y - enemy.pos.y;
                const distancia = Math.sqrt(dx * dx + dy * dy);
                
                if (distancia < 15) {
                    if (enemy.type === 'blue') {
                        aplicarEfeitoCongelamento(enemy);
                    } else {
                        if (extraLife) {
                            extraLife = false;
                            extraLifeIcon.style.display = 'none';
                        } else {
                            fimDeJogo();
                            return;
                        }
                    }
                }

                if(enemy.type === 'purple') {
                    moverInimigoRoxo(enemy);
                } else {
                    moverInimigoVerde(enemy);
                }
            }

            updateEnemyPosition();
        }

        function fimDeJogo() {
            clearInterval(gameLoop);
            clearInterval(obstacleMovementInterval);
            clearInterval(timerInterval);
            clearInterval(spawnInterval);
            clearInterval(perkInterval);
            tempoFinalElement.textContent = timerElement.textContent;
            gameOver.style.display = 'block';
            
            // Salvar a pontuação ao fim do jogo
            salvarPontuacao(timerElement.textContent);
        }

        function reiniciarJogo() {
            // Limpar todos os intervalos anteriores para garantir
            clearInterval(gameLoop);
            clearInterval(obstacleMovementInterval);
            clearInterval(timerInterval);
            clearInterval(spawnInterval);
            clearInterval(perkInterval);
            
            obstacles.forEach(obs => obs.element.remove());
            obstacles.length = 0;
            
            enemies.slice(2).forEach(enemy => {
                if (enemy && enemy.element) {
                    enemy.element.remove();
                }
            });
            enemies = enemies.slice(0, 2);
            
            playerPos = { x: window.innerWidth/2, y: window.innerHeight/2 };
            enemies[0].pos = { x: 50, y: 50 };
            enemies[0].direcao = Math.random() * 2 * Math.PI;
            enemies[1].pos = { x: window.innerWidth - 80, y: window.innerHeight - 80 };
            
            updatePlayerPosition();
            updateEnemyPosition();
            gameOver.style.display = 'none';
            
            criarObstaculos();
            iniciarJogo();
        }

        function iniciarJogo() {
            startTime = Date.now() - tempoDecorrido * 1000;
            lastNavMeshUpdate = 0;
            
            gameLoop = setInterval(() => {
                moverInimigo();
                atualizarMovimentoJogador();
            }, 1000/60);

            obstacleMovementInterval = setInterval(moverObstaculos, 1000/30);
            timerInterval = setInterval(atualizarTimer, 1000);
            spawnInterval = setInterval(criarNovoInimigo, 4000);
            perkInterval = setInterval(mostrarTelaPerks, 60000); // Mostrar tela de perks a cada 1 minuto
        }

        function atualizarMovimentoJogador() {
            let newX = playerPos.x;
            let newY = playerPos.y;

            if (teclasPressionadas['ArrowUp'] || teclasPressionadas['w'] || teclasPressionadas['W']) newY -= playerSpeed;
            if (teclasPressionadas['ArrowDown'] || teclasPressionadas['s'] || teclasPressionadas['S']) newY += playerSpeed;
            if (teclasPressionadas['ArrowLeft'] || teclasPressionadas['a'] || teclasPressionadas['A']) newX -= playerSpeed;
            if (teclasPressionadas['ArrowRight'] || teclasPressionadas['d'] || teclasPressionadas['D']) newX += playerSpeed;

            if (newX >= 0 && newX <= window.innerWidth - 30 && 
                newY >= 0 && newY <= window.innerHeight - 30) {
                if (!checkCollision(newX, newY)) {
                    playerPos.x = newX;
                    playerPos.y = newY;
                    updatePlayerPosition();
                }
            }
        }

        function mostrarTelaPerks() {
            clearInterval(gameLoop);
            clearInterval(obstacleMovementInterval);
            clearInterval(spawnInterval);
            telaPerks.style.display = 'flex';
        }

        function escolherPerk(perk) {
            telaPerks.style.display = 'none';
            switch (perk) {
                case 'extraLife':
                    extraLife = true;
                    extraLifeIcon.style.display = 'block';
                    break;
                case 'speedBoost':
                    playerSpeed *= 1.5;
                    break;
                case 'explosion':
                    explosionAvailable = true;
                    explosionIcon.style.display = 'block';
                    break;
            }
            gameLoop = setInterval(() => {
                moverInimigo();
                atualizarMovimentoJogador();
            }, 1000/60);

            obstacleMovementInterval = setInterval(moverObstaculos, 1000/30);
            spawnInterval = setInterval(criarNovoInimigo, 4000);
        }

        window.addEventListener('resize', () => {
            reiniciarJogo();
        });

        document.addEventListener('keydown', (e) => {
            teclasPressionadas[e.key] = true;
            if (e.key === ' ' && explosionAvailable) {
                criarExplosao(playerPos.x + 15, playerPos.y + 15);
                explosionAvailable = false;
                explosionIcon.style.display = 'none';
            }
        });

        document.addEventListener('keyup', (e) => {
            teclasPressionadas[e.key] = false;
        });

        document.addEventListener('touchmove', (e) => {
            const touch = e.touches[0];
            const rect = gameArea.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            mobileCursor.style.left = `${x - 15}px`;
            mobileCursor.style.top = `${y - 15}px`;
            playerPos.x = x - 15;
            playerPos.y = y - 15;
            updatePlayerPosition();
        });

        criarObstaculos();
        updatePlayerPosition();
        updateEnemyPosition();
        iniciarJogo();
    </script>
</body>
</html>
